// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/Shuri-Honda-1101/cat-utils/ent"

func NewCatCreate(e *ent.Cat) *CatCreate {
	if e == nil {
		return nil
	}
	var ret CatCreate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Birthday = NewOptDateTime(e.Birthday)
	ret.Sex = CatCreateSex(e.Sex)
	ret.Weight = NewOptInt(e.Weight)
	return &ret
}

func NewCatCreates(es []*ent.Cat) []CatCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]CatCreate, len(es))
	for i, e := range es {
		r[i] = NewCatCreate(e).Elem()
	}
	return r
}

func (c *CatCreate) Elem() CatCreate {
	if c == nil {
		return CatCreate{}
	}
	return *c
}

func NewCatList(e *ent.Cat) *CatList {
	if e == nil {
		return nil
	}
	var ret CatList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Birthday = NewOptDateTime(e.Birthday)
	ret.Sex = CatListSex(e.Sex)
	ret.Weight = NewOptInt(e.Weight)
	return &ret
}

func NewCatLists(es []*ent.Cat) []CatList {
	if len(es) == 0 {
		return nil
	}
	r := make([]CatList, len(es))
	for i, e := range es {
		r[i] = NewCatList(e).Elem()
	}
	return r
}

func (c *CatList) Elem() CatList {
	if c == nil {
		return CatList{}
	}
	return *c
}

func NewCatRead(e *ent.Cat) *CatRead {
	if e == nil {
		return nil
	}
	var ret CatRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Birthday = NewOptDateTime(e.Birthday)
	ret.Sex = CatReadSex(e.Sex)
	ret.Weight = NewOptInt(e.Weight)
	return &ret
}

func NewCatReads(es []*ent.Cat) []CatRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]CatRead, len(es))
	for i, e := range es {
		r[i] = NewCatRead(e).Elem()
	}
	return r
}

func (c *CatRead) Elem() CatRead {
	if c == nil {
		return CatRead{}
	}
	return *c
}

func NewCatUpdate(e *ent.Cat) *CatUpdate {
	if e == nil {
		return nil
	}
	var ret CatUpdate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Birthday = NewOptDateTime(e.Birthday)
	ret.Sex = CatUpdateSex(e.Sex)
	ret.Weight = NewOptInt(e.Weight)
	return &ret
}

func NewCatUpdates(es []*ent.Cat) []CatUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]CatUpdate, len(es))
	for i, e := range es {
		r[i] = NewCatUpdate(e).Elem()
	}
	return r
}

func (c *CatUpdate) Elem() CatUpdate {
	if c == nil {
		return CatUpdate{}
	}
	return *c
}

func NewCatOwnerRead(e *ent.User) *CatOwnerRead {
	if e == nil {
		return nil
	}
	var ret CatOwnerRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	return &ret
}

func NewCatOwnerReads(es []*ent.User) []CatOwnerRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]CatOwnerRead, len(es))
	for i, e := range es {
		r[i] = NewCatOwnerRead(e).Elem()
	}
	return r
}

func (u *CatOwnerRead) Elem() CatOwnerRead {
	if u == nil {
		return CatOwnerRead{}
	}
	return *u
}

func NewCatToiletsList(e *ent.Toilet) *CatToiletsList {
	if e == nil {
		return nil
	}
	var ret CatToiletsList
	ret.ID = e.ID
	ret.Time = e.Time
	ret.Type = CatToiletsListType(e.Type)
	ret.Memo = NewOptString(e.Memo)
	return &ret
}

func NewCatToiletsLists(es []*ent.Toilet) []CatToiletsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]CatToiletsList, len(es))
	for i, e := range es {
		r[i] = NewCatToiletsList(e).Elem()
	}
	return r
}

func (t *CatToiletsList) Elem() CatToiletsList {
	if t == nil {
		return CatToiletsList{}
	}
	return *t
}

func NewToiletCreate(e *ent.Toilet) *ToiletCreate {
	if e == nil {
		return nil
	}
	var ret ToiletCreate
	ret.ID = e.ID
	ret.Time = e.Time
	ret.Type = ToiletCreateType(e.Type)
	ret.Memo = NewOptString(e.Memo)
	return &ret
}

func NewToiletCreates(es []*ent.Toilet) []ToiletCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ToiletCreate, len(es))
	for i, e := range es {
		r[i] = NewToiletCreate(e).Elem()
	}
	return r
}

func (t *ToiletCreate) Elem() ToiletCreate {
	if t == nil {
		return ToiletCreate{}
	}
	return *t
}

func NewToiletList(e *ent.Toilet) *ToiletList {
	if e == nil {
		return nil
	}
	var ret ToiletList
	ret.ID = e.ID
	ret.Time = e.Time
	ret.Type = ToiletListType(e.Type)
	ret.Memo = NewOptString(e.Memo)
	return &ret
}

func NewToiletLists(es []*ent.Toilet) []ToiletList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ToiletList, len(es))
	for i, e := range es {
		r[i] = NewToiletList(e).Elem()
	}
	return r
}

func (t *ToiletList) Elem() ToiletList {
	if t == nil {
		return ToiletList{}
	}
	return *t
}

func NewToiletRead(e *ent.Toilet) *ToiletRead {
	if e == nil {
		return nil
	}
	var ret ToiletRead
	ret.ID = e.ID
	ret.Time = e.Time
	ret.Type = ToiletReadType(e.Type)
	ret.Memo = NewOptString(e.Memo)
	return &ret
}

func NewToiletReads(es []*ent.Toilet) []ToiletRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ToiletRead, len(es))
	for i, e := range es {
		r[i] = NewToiletRead(e).Elem()
	}
	return r
}

func (t *ToiletRead) Elem() ToiletRead {
	if t == nil {
		return ToiletRead{}
	}
	return *t
}

func NewToiletUpdate(e *ent.Toilet) *ToiletUpdate {
	if e == nil {
		return nil
	}
	var ret ToiletUpdate
	ret.ID = e.ID
	ret.Time = e.Time
	ret.Type = ToiletUpdateType(e.Type)
	ret.Memo = NewOptString(e.Memo)
	return &ret
}

func NewToiletUpdates(es []*ent.Toilet) []ToiletUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ToiletUpdate, len(es))
	for i, e := range es {
		r[i] = NewToiletUpdate(e).Elem()
	}
	return r
}

func (t *ToiletUpdate) Elem() ToiletUpdate {
	if t == nil {
		return ToiletUpdate{}
	}
	return *t
}

func NewToiletCatRead(e *ent.Cat) *ToiletCatRead {
	if e == nil {
		return nil
	}
	var ret ToiletCatRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Birthday = NewOptDateTime(e.Birthday)
	ret.Sex = ToiletCatReadSex(e.Sex)
	ret.Weight = NewOptInt(e.Weight)
	return &ret
}

func NewToiletCatReads(es []*ent.Cat) []ToiletCatRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ToiletCatRead, len(es))
	for i, e := range es {
		r[i] = NewToiletCatRead(e).Elem()
	}
	return r
}

func (c *ToiletCatRead) Elem() ToiletCatRead {
	if c == nil {
		return ToiletCatRead{}
	}
	return *c
}

func NewUserCreate(e *ent.User) *UserCreate {
	if e == nil {
		return nil
	}
	var ret UserCreate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	return &ret
}

func NewUserCreates(es []*ent.User) []UserCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCreate, len(es))
	for i, e := range es {
		r[i] = NewUserCreate(e).Elem()
	}
	return r
}

func (u *UserCreate) Elem() UserCreate {
	if u == nil {
		return UserCreate{}
	}
	return *u
}

func NewUserList(e *ent.User) *UserList {
	if e == nil {
		return nil
	}
	var ret UserList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	return &ret
}

func NewUserLists(es []*ent.User) []UserList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserList, len(es))
	for i, e := range es {
		r[i] = NewUserList(e).Elem()
	}
	return r
}

func (u *UserList) Elem() UserList {
	if u == nil {
		return UserList{}
	}
	return *u
}

func NewUserRead(e *ent.User) *UserRead {
	if e == nil {
		return nil
	}
	var ret UserRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	return &ret
}

func NewUserReads(es []*ent.User) []UserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserRead, len(es))
	for i, e := range es {
		r[i] = NewUserRead(e).Elem()
	}
	return r
}

func (u *UserRead) Elem() UserRead {
	if u == nil {
		return UserRead{}
	}
	return *u
}

func NewUserUpdate(e *ent.User) *UserUpdate {
	if e == nil {
		return nil
	}
	var ret UserUpdate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	return &ret
}

func NewUserUpdates(es []*ent.User) []UserUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserUpdate, len(es))
	for i, e := range es {
		r[i] = NewUserUpdate(e).Elem()
	}
	return r
}

func (u *UserUpdate) Elem() UserUpdate {
	if u == nil {
		return UserUpdate{}
	}
	return *u
}

func NewUserCatsList(e *ent.Cat) *UserCatsList {
	if e == nil {
		return nil
	}
	var ret UserCatsList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Birthday = NewOptDateTime(e.Birthday)
	ret.Sex = UserCatsListSex(e.Sex)
	ret.Weight = NewOptInt(e.Weight)
	return &ret
}

func NewUserCatsLists(es []*ent.Cat) []UserCatsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCatsList, len(es))
	for i, e := range es {
		r[i] = NewUserCatsList(e).Elem()
	}
	return r
}

func (c *UserCatsList) Elem() UserCatsList {
	if c == nil {
		return UserCatsList{}
	}
	return *c
}
